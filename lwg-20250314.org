#+options: ':nil *:t -:t ::t <:t H:8 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:nil expand-links:t f:t inline:t num:t p:nil pri:nil prop:nil
#+options: stat:t tags:t tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+title: lwg-20250314
#+date: <2025-03-14 Fri>
#+author: Steve Downey
#+email: sdowney@pwyll
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 30.1.50 (Org mode 9.7.11)
#+cite_export:

#+options: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+options: html-scripts:t html-style:t html5-fancy:nil tex:t
#+html_doctype: xhtml-strict
#+html_container: div
#+html_content_class: content
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_equation_reference_format: \eqref{%s}
#+html_head:
#+html_head_extra:
#+subtitle:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.1.50 (<a href="https://orgmode.org">Org</a> mode 9.7.11)
#+latex_header:

* Notes
https://wg21.link/P2988r9 std::optional<T&>
SD presenting
[optionalref.iterators]
TS: p1: “These types” -> “This type”
DK: there is no const_iterator?
SD: no, constness is shallow
JW: should there be a const_iterator typedef?
TK: no, it would be a lie
JW: “referring to the referred to value”
TK: referring to *val
SD: I have “referring to the contained value”
[optionalref.observe]
SD: there should be hardened preconditions once that landed
JW: make value() a one-liner as in non-specialization
TK: value_or should remove_cv_t
TK: the mandate shouldn’t have a std:: qualification
JW: should the stable names use [optional.ref]
JW: also a one-liner on value_or
JW: we did something on value_or() to allow using {} as argument
JW: the Mandate on value_or() looks different
SD: over here it is a bit longer and we should probably fix the other one
[optionalref.monadics]
TK: in p3 it becomes valid contained type?
SD: yes
JW: in p7 what is U? There is something missing
TK: it should be invoke_result_t<F>
TK: the definition of U should be consistent
JW: in p4: we shouldn’t use trailing return types here
TK: we can remove the mandates
SD: no, it is needed
JW: now that there is a “contains” we could write it exactly the same as normal optional
TK: we want to use the same wording for transform()
Stopping before [optionalref.mod]

* Checklist
SD presenting
[optionalref.iterators]
- [ ] TS: p1: “These types” -> “This type”
DK: there is no const_iterator?
SD: no, constness is shallow
JW: should there be a const_iterator typedef?
TK: no, it would be a lie
JW: “referring to the referred to value”
TK: referring to *val
SD: I have “referring to the contained value”
[optionalref.observe]
SD: there should be hardened preconditions once that landed
- [ ] JW: make value() a one-liner as in non-specialization
- [ ] TK: value_or should remove_cv_t
- [ ] TK: the mandate shouldn’t have a std:: qualification
- [ ] JW: should the stable names use [optional.ref]
- [ ] JW: also a one-liner on value_or
- [ ] JW: we did something on value_or() to allow using {} as argument
JW: the Mandate on value_or() looks different
SD: over here it is a bit longer and we should probably fix the other one
[optionalref.monadics]
TK: in p3 it becomes valid contained type?
SD: yes
- [ ] JW: in p7 what is U? There is something missing
- [ ] TK: it should be invoke_result_t<F>
TK: the definition of U should be consistent
- [ ] JW: in p4: we shouldn’t use trailing return types here
TK: we can remove the mandates
SD: no, it is needed
JW: now that there is a “contains” we could write it exactly the same as normal optional
- [ ] TK: we want to use the same wording for transform()
Stopping before [optionalref.mod]

Note add "contained value" definition for optional<T&>
